CAR-CONTROLLER:
    -GET by Id - CHECK
    -GET by model - CHECK
    -GET pages - 2 queries
    -GET all - CHECK

USERS-CONTROLLER:
    -GET all users - CHECK
    -GET all comments by id - CHECK
    -GET all users name - CHECK
    -GET all comments by name - CHECK

COMMENT-CONTROLLER:
    -GET by id - CHECK
    -GET search by Car and User - CHECK

CATEGORY-CONTROLLER:
    -GET by id - CHECK
    -GET by list ids - CHECK
    -GET all category - CHECK

Типа сделать проекции для вывода, там не надо будет использовать Entity Graph

Сделать добавления комментариев, сделать валидацию на проверку входных значений и возврат об ошибке, чтобы было понятно, где ошибка

Сделать удаление, например, чтобы удалять пользователей и в результате удалялись все комменты, и также с машинами

Чтобы возвращалась Data: машина комментарии пользователь.
Посмотреть про проекции

Удаление:
    Удаление пользователя приводит к удалению комментов
    Удаление машин приводит к удалению комментов о машинах


spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/your_database_name
    username: your_username
    password: your_password
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
        show_sql: true

server:
  port: 8080

logging:
  level:
    org.springframework: INFO
    org.hibernate.SQL: DEBUG


в запросе чотко указывать к методу as name к getname



@Getter
@Setter
@Entity
@Table(name = "cars")
public class Cars {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String model;

    @ManyToMany
    //@BatchSize(size = 10) //FetchType.Eager
    @JoinTable(
            name = "car_categories",
            joinColumns = @JoinColumn(name = "cars_id"),
            inverseJoinColumns = @JoinColumn(name = "category_id")
    )
    Set<Category> categories;

    @OneToMany(mappedBy="car", cascade = CascadeType.ALL,orphanRemoval = true)
    @BatchSize(size = 10)
    private List<Comment> comments;
}
@Getter
@Setter
@Entity
@Table(name = "users")
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(nullable = false)
    private String name;

    @OneToMany(mappedBy="userOne", cascade = CascadeType.ALL,orphanRemoval = true)
    //@BatchSize(size=10)
    private List<Comment> comments;
}
@Getter
@Setter
@Entity
@Table(name = "comment")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Проверка
    private Integer id;

    @Column(nullable = false)
    private String commentContent;

    @ManyToOne
    @JoinColumn(name="users_id",nullable = false)
    private Users userOne;

    @ManyToOne
    @JoinColumn(name="cars_id",nullable = false)
    private Cars car;
}
@Getter
@Setter
@Entity
@Table(name = "category")
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    private String name;

    public Category (String name) {
        this.name = name;
    }
}
public interface CarsRepo extends JpaRepository<Cars, Integer> {
Optional<CarFull> findCarsById(Integer id);
}
public interface CarFull {
    String getModel();

    Set<CategoryProjection> getCategories();

    List<CommentUser> getComments();

    interface CategoryProjection {
        String getName();
    }

    interface CommentProjection {
        Integer getId(); //testing
        String getCommentContent();
        UserProjection getUserOne();

        interface UserProjection {
            String getName();
        }
    }
}
Как написать Query, чтобы выполнялся метод findCarsById из репозитория, чтобы был вызван только один запрос



@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String firstName;
    private String lastName;
    private String email;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
    // Getters and setters
}

@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long
    private String product;
    private double price;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    // Getters and setters
}

public interface UserSummaryProjection {
    String getFirstName();
    String getEmail();
    int getOrderCount();
}

public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u.firstName as firstName, u.email as email, COUNT(o) as orderCount " +
           "FROM User u LEFT JOIN u.orders o GROUP BY u")
    List<UserSummaryProjection> findUserSummaries();
}

